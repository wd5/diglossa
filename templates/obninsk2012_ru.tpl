
<h4>МорфЕус, морфологический анализатор латинского языка</h4>
</p>
<p>доклад на конференции <a href="http://www.altlinux.ru/news/archive/2012/06/item/671/">Девятая конференция разработчиков свободных программ, Обнинск</a></p>

<p><b>summary</b>: Морфеус [0], морфологический анализатор латинского языка, построен с использованием стандартных методов веб-разработки на языке Ruby и CouchDb. Имеет систему тестов, "гарантирующих" корректность полученных результатов. Имеет лицензию GNU-GPL</p>

<p>Большинство известных мне морфологических анализаторов построены на основе openSFT [1] - на конечных преобразователях. То есть на преобразовании строк с помощью регулярных выражений. Получающееся в результате чудовищное (много экранов) регулярное выражение компилируется в бинарник, способный очень быстро обработать большой объем текста. Происходит преобразование строка (анализируемое слово) -> строка (морфологический анализ этого слова). В результате получается немодифицируемый, очень сложный бинарник. Очевидно, что он может быть только коммерческим продуктом. Это очень трудоемкий подход. В Морфеусе я предлагаю, напротив, подход более человечный. Все данные о парадигмах языка хранятся в JSON и легко читаются и модифицируются человеком. Обрабатываются не строки, а ruby (на сервере) или Javascript (на клиенте) объекты.  </p>

<p>Алгоритм работы простого морфологического анализатора таков:  Каждая словоформа проходит через сито парадигм и связанных с ним правил, и на первом шаге 1) выявляются парадигмы, способные породить данную словоформу и возможные словарные формы, затем на втором 2) выбираются только те парадигмы, которые порождают действительно существующее в словаре слово и наконец 3) результат кешируется в БД. Вдобавок есть механизм заполнения базы словоформ исключениями, (терминами, не требующими никакого анализа, вне системы парадигм.). Все происходит в NoSQL-БД (поскольку json), а именно в CouchDB [2].</p>

<p>По сравнению со временем работы скомпилированного openSFT выражения, это медленный подход. Впрочем, нужно сравнивать не со временем выполнения скомпилированного SFT-приложения, а со временем его компиляции. А это также долго. Зато мгновенной результат - время обращения к базе.</p>

<p>Преимущества: 1) знакомые и обкатанные веб-технологии, все на http-rest запросах, все на стандартных библиотеках обработки ruby-хеша или js-объекта. И 2) крайняя простота и человекоразмерность данного подхода, 3) возможность постепенного улучшения анализатора, 4) возможность коллективной работы. И - очень важно - прозрачная возможность предварительной и заключительной (синтаксической, контекстной) обработки поступающего потока текста.</p>

<p>А именно, собственно морфологический анализатор является лишь частью процесса. Полностью процесс выглядит так: </p>

<p>Вначале клиент (браузер) посылает анализируемую строку на сервер. Сервер выполняет предварительный анализ строки, выделяя предложения, части предложения (главные, подчиненные), и обращается к Морфеусу за морфологическим анализом каждой словоформы. В результате получается упорядоченный массив морфологических данных. На следующем этапе выполняется частичный синтаксический анализ, а именно, находятся жестко связанные между собой слова, например предлог, сочетающийся только с определенным падежом, или причастие и определенная форма глагола esse, прилагательное плюс его существительное, и т.д. На этом же этапе мы можем отбросить "лишние" морфологические результаты, избавившись от неопределенности морфологического анализа (в том распространенном случае, когда морфологический анализ вырванной из контекста словоформы дает несколько взаимоисключающих результатов). Наконец, приходит время terra incognita - полноценного синтаксического анализа. В результате же должен получиться граф синтаксических связей предложения. Но это - дело будущего, крайне заманчивое.</p>

<p>Отдельно я хочу отметить, что данный подход опирается на тесты, точнее, спецификации. И является примером стандартного BDD-style [3] способа разработки. Я использовал несколько источников "верного ответа" для создания спецификации. В основном, программу words Уильяма Уитеккера [4]. Каждая парадигма имеет исчерпывающий набор примеров, и разработка ведется до тех ровно пор, пока все полученные морфологические формы не совпадут с "верными" ответами. Кавычки я употребляю потому, что и в программу Уитеккера (лучшей из всех), и на сайте Персея [5], и на сайте Wiktionary [6] существует масса расхождений и между собой, и с известными мне учебниками. Улучшение работы Морфеуса сверх этих черновых BDD-спецификаций, т.е. полировка программы, потребует работы уже не программистов, но лингвистов и филологов и, видимо, годы труда.</p>

<p> В качестве вывода, я хотел бы предложить, чтобы на основе этого подхода, или схожих с ним,</p>

<p>1) объединились бы люди, разрабатывающие подобные морфологические анализаторы для всех близких нам языков, всех главных европейских языков, и всех языков будущего ЕАС, древних языков и т.д. На основе свободного софта</p>

<p>2) возникла бы общедоступная веб-служба с простым стандартным API для запроса анализа любой словоформы любого языка. </p>

<p><b>Некоторые подробности.</b></p>

<p> Морфеус написан на руби и имеет несколько удобных для работы классов с самообъясняющими названиями: Paradigm, Dict, Term (для исключений), Spec и некоторые вспомогательные классы, например Couch для работы с Кауч-DB.</p>

<p>> load 'morpheus.rb'</p>

<p>пример парадигмы:</p>

<br> > pp Morpheus::Paradigm.get "verb_act_fut-perf_ind" 
<br>[{:_id=>"8417feaa0669fda52d6d4d8d2b409302",
<br>  :_rev=>"1-b2cd18b4cc2d616ed767fb7b47401940",
<br>  :type=>"latin-paradigm",
<br>  :pos=>"verb",
<br>  :descr=>"act.fut-perf.ind",
<br>  :dict=>"i",
<br>  :flexes=>
<br>   {:"sg.1"=>"ero",
<br>    :"sg.2"=>"eris",
<br>    :"sg.3"=>"erit",
<br>    :"pl.1"=>"erimus",
<br>    :"pl.2"=>"eritis",
<br>    :"pl.3"=>"erint"}... часть вывода опущена для ясности]
<br>
<p>&nbsp;</p>
<p>пример вычисления возможных словарных форм:</p>

<br>> pp Morpheus::Morph.guess "aquae"
<br>{:nouns=>
<br>  [{:pos=>"noun",
<br>    :dict=>"aqua",
<br>    :descr=>"prima",
<br>    :gend=>"fem",
<br>    :stem=>"aqu",
<br>    :full=>"aquae",
<br>    :sggen=>"ae",
<br>    :morphs=>["pl.nom", "pl.voc", "sg.dat", "sg.gen"],
<br>    :var=>"a"},
<br>   {:pos=>"noun",
<br>    :dict=>"aqua",
<br>    :descr=>"prima",
<br>    :gend=>"masc",
<br>    :stem=>"aqu",
<br>    :full=>"aquae",
<br>    :sggen=>"ae",
<br>....
<br> :adjs=>
<br>  [{:pos=>"adj",
<br>    :dict=>"aquus",
<br>    :descr=>"primsec",
<br>    :gend=>"fem",
<br>    :stem=>"aqu",
<br>    :full=>"aquae",
<br>    :sggen=>"ae",
<br>    :morphs=>["pl.nom", "pl.voc", "sg.dat", "sg.gen"],
<br>    :grad=>"pos",
<br>    :var=>"us-f"},
<br>  ...
<br>:parts=>[],
<br> :verbs=>
<br>  [{:pos=>"verb",
<br>    :dict=>"aquaeo",
<br>    :descr=>"act.pres.imp",
<br>    :stem=>"aqua",
<br>    :morphs=>["sg.2"],
<br>    :var=>2},
<br>....
<br>:infs=>[]}
<br>

<p>&nbsp;</p>
<p>пример получения окончательного результата: </p>

<p> > pp Morpheus::Morph.parse "aquae" </p>

<br>[{:pos=>"noun",
<br>  :dict=>"aqua",
<br>  :form=>"aquae",
<br>  :morphs=>
<br>   [{:gend=>"fem", :number=>"pl", :kase=>"nom"},
<br>    {:gend=>"fem", :number=>"pl", :kase=>"voc"},
<br>    {:gend=>"fem", :number=>"sg", :kase=>"dat"},
<br>    {:gend=>"fem", :number=>"sg", :kase=>"gen"}],
<br>  :type=>"latin-form"}]
 
<p>&nbsp;</p>

<p>Спасибо за внимание, </p>

<p>Михаил Быков</p>


<br>[0] https://github.com/mbykov/morph-couch
<br>[1] http://wiki.apache.org/couchdb/FrontPage
<br>[2] http://www.openfst.org/twiki/bin/view/FST/WebHome
<br>[3] http://rspec.info/
<br>[4] http://ablemedia.com/ctcweb/showcase/whitakerwords.html
<br>[5] http://www.perseus.tufts.edu/hopper/morph?la=la&l=rationi
<br>[6] http://en.wiktionary.org/wiki/aquae#Latin

